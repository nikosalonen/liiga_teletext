//! Layout calculation module for dynamic UI sizing
//!
//! This module provides functionality for calculating optimal layouts based on terminal
//! dimensions, determining appropriate detail levels, and managing content positioning.
//!
//! ## Features
//!
//! - **Dynamic Layout Calculation**: Automatically adjusts layout based on terminal size
//! - **Detail Level Management**: Provides three detail levels (Minimal, Standard, Extended)
//! - **Performance Caching**: Caches layout calculations with TTL for improved performance
//! - **Incremental Updates**: Optimizes small terminal size changes with incremental updates
//! - **String Buffer Pool**: Reuses string buffers to reduce memory allocations
//! - **Graceful Degradation**: Handles very small terminal sizes with emergency layouts
//!
//! ## Usage
//!
//! ```rust
//! use crate::ui::layout::LayoutCalculator;
//!
//! let mut calculator = LayoutCalculator::new();
//! let layout = calculator.calculate_layout((100, 30));
//!
//! // Use layout configuration for rendering
//! println!("Content area: {}x{}", layout.content_width, layout.content_height);
//! println!("Games per page: {}", layout.games_per_page);
//! println!("Detail level: {:?}", layout.detail_level);
//! ```
//!
//! ## Performance Optimizations
//!
//! - Layout calculations are cached for 500ms to avoid redundant calculations
//! - Incremental updates are used for small terminal size changes (±5 width, ±3 height)
//! - String buffer pool reduces memory allocations during rendering
//! - Expired cache entries are cleaned up automatically every 30 seconds

use crate::constants::dynamic_ui;
use crate::error::AppError;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tracing::{debug, trace, warn};

/// Represents different levels of detail for content display
///
/// The detail level determines how much information is shown based on available screen space:
/// - **Minimal**: Basic game information (team names, scores, time) - used for terminals < 100 chars wide
/// - **Standard**: Enhanced information with longer team names and more precise timing - used for 100-119 chars wide
/// - **Extended**: Full detail with complete team names, detailed goal information, and extended stats - used for ≥120 chars wide
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DetailLevel {
    /// Minimal detail for small screens (current behavior)
    /// Used when terminal width < 100 characters
    Minimal,
    /// Standard detail for medium screens with enhanced information
    /// Used when terminal width is 100-119 characters
    Standard,
    /// Extended detail for large screens with full information
    /// Used when terminal width ≥ 120 characters
    Extended,
}

/// Configuration for layout calculations
///
/// This structure contains all the calculated layout parameters needed for rendering
/// the UI. It's generated by `LayoutCalculator::calculate_layout()` based on terminal
/// dimensions and cached for performance.
#[derive(Debug, Clone)]
pub struct LayoutConfig {
    /// Available width for content display (excluding padding and margins)
    pub content_width: u16,
    /// Available height for content display (excluding header and footer)
    pub content_height: u16,
    /// Number of games that can fit per page based on detail level and available height
    pub games_per_page: usize,
    /// Detail level to use for content rendering (Minimal/Standard/Extended)
    pub detail_level: DetailLevel,
    /// Horizontal padding on each side of the content
    pub horizontal_padding: u16,
    /// Whether this layout is using emergency fallback mode for very small terminals
    pub is_emergency_mode: bool,
    /// Warning message if layout had to be degraded due to size constraints
    pub degradation_warning: Option<String>,
}

/// Positioning information for UI elements
#[derive(Debug, Clone)]
pub struct ContentPositioning {
    /// Y position for header
    pub header_y: u16,
    /// Y position where content starts
    pub content_start_y: u16,
    /// Y position where content ends
    pub content_end_y: u16,
    /// Y position for footer
    pub footer_y: u16,
    /// Left margin for content
    pub left_margin: u16,
    /// Right margin for content
    pub right_margin: u16,
}

/// Statistics about layout cache performance
#[derive(Debug, Clone)]
pub struct LayoutCacheStats {
    /// Total number of cached entries
    pub total_entries: usize,
    /// Number of expired entries
    pub expired_entries: usize,
    /// Number of active (non-expired) entries
    pub active_entries: usize,
    /// Number of buffers in the string buffer pool
    pub buffer_pool_size: usize,
}

/// Cached layout data with TTL support
#[derive(Debug, Clone)]
struct CachedLayoutData {
    config: LayoutConfig,
    cached_at: Instant,
    terminal_size: (u16, u16),
}

impl CachedLayoutData {
    fn new(config: LayoutConfig, terminal_size: (u16, u16)) -> Self {
        Self {
            config,
            cached_at: Instant::now(),
            terminal_size,
        }
    }

    fn is_expired(&self) -> bool {
        self.cached_at.elapsed() > Duration::from_millis(dynamic_ui::LAYOUT_CACHE_TTL_MS)
    }

    fn is_size_match(&self, terminal_size: (u16, u16)) -> bool {
        self.terminal_size == terminal_size
    }

    fn is_incremental_update(&self, terminal_size: (u16, u16)) -> bool {
        let (old_width, old_height) = self.terminal_size;
        let (new_width, new_height) = terminal_size;

        // Consider it incremental if the change is small
        let width_diff = (old_width as i32 - new_width as i32).abs();
        let height_diff = (old_height as i32 - new_height as i32).abs();

        width_diff <= dynamic_ui::INCREMENTAL_WIDTH_THRESHOLD
            && height_diff <= dynamic_ui::INCREMENTAL_HEIGHT_THRESHOLD
    }
}

/// String buffer pool for optimized rendering
#[derive(Debug)]
struct StringBufferPool {
    buffers: Vec<String>,
    max_capacity: usize,
}

impl StringBufferPool {
    fn new(max_capacity: usize) -> Self {
        Self {
            buffers: Vec::with_capacity(4),
            max_capacity,
        }
    }

    fn get_buffer(&mut self, estimated_size: usize) -> String {
        if let Some(mut buffer) = self.buffers.pop() {
            buffer.clear();
            if buffer.capacity() < estimated_size {
                buffer.reserve(estimated_size - buffer.capacity());
            }
            buffer
        } else {
            String::with_capacity(estimated_size)
        }
    }

    fn return_buffer(&mut self, buffer: String) {
        if self.buffers.len() < self.max_capacity
            && buffer.capacity() <= dynamic_ui::MAX_STRING_BUFFER_CAPACITY
        {
            self.buffers.push(buffer);
        }
    }
}

/// Handles layout calculations for dynamic UI sizing with caching
///
/// The `LayoutCalculator` is the main component responsible for determining optimal
/// layouts based on terminal dimensions. It includes several performance optimizations:
///
/// - **Caching**: Layout calculations are cached with a 500ms TTL to avoid redundant work
/// - **Incremental Updates**: Small terminal size changes use incremental updates instead of full recalculation
/// - **String Buffer Pool**: Maintains a pool of reusable string buffers for rendering
/// - **Automatic Cleanup**: Expired cache entries are cleaned up periodically
///
/// ## Thread Safety
///
/// This structure is not thread-safe and should be used from a single thread.
/// Each UI instance should have its own `LayoutCalculator`.
#[derive(Debug)]
pub struct LayoutCalculator {
    /// Minimum terminal width for normal operation
    min_width: u16,
    /// Minimum terminal height for normal operation
    min_height: u16,
    /// Current terminal dimensions (width, height)
    current_dimensions: (u16, u16),
    /// Cache of calculated layouts indexed by terminal size
    layout_cache: HashMap<(u16, u16), CachedLayoutData>,
    /// Timestamp of last cache cleanup operation
    last_cache_cleanup: Instant,
    /// Pool of reusable string buffers for rendering optimization
    string_buffer_pool: StringBufferPool,
}

impl LayoutCalculator {
    /// Creates a new LayoutCalculator with default minimum dimensions
    pub fn new() -> Self {
        Self {
            min_width: dynamic_ui::MIN_TERMINAL_WIDTH,
            min_height: dynamic_ui::MIN_TERMINAL_HEIGHT,
            current_dimensions: (
                dynamic_ui::MIN_TERMINAL_WIDTH,
                dynamic_ui::MIN_TERMINAL_HEIGHT,
            ),
            layout_cache: HashMap::new(),
            last_cache_cleanup: Instant::now(),
            string_buffer_pool: StringBufferPool::new(dynamic_ui::MAX_STRING_BUFFER_POOL_SIZE),
        }
    }

    /// Calculates optimal layout configuration for given terminal size with caching
    pub fn calculate_layout(&mut self, terminal_size: (u16, u16)) -> LayoutConfig {
        self.current_dimensions = terminal_size;

        // Clean up expired cache entries periodically
        self.cleanup_cache_if_needed();

        // Check cache first
        if let Some(cached) = self.layout_cache.get(&terminal_size) {
            if !cached.is_expired() && cached.is_size_match(terminal_size) {
                trace!("Layout cache hit for terminal size: {:?}", terminal_size);
                return cached.config.clone();
            }
        }

        // Check for incremental update opportunity
        if let Some(cached) = self.find_incremental_update_candidate(terminal_size) {
            if let Some(updated_config) = self.try_incremental_update(cached, terminal_size) {
                trace!(
                    "Layout incremental update for terminal size: {:?}",
                    terminal_size
                );
                self.cache_layout(terminal_size, updated_config.clone());
                return updated_config;
            }
        }

        trace!(
            "Layout cache miss, calculating new layout for terminal size: {:?}",
            terminal_size
        );

        // Calculate new layout
        let config = self.calculate_layout_uncached(terminal_size);

        // Cache the result
        self.cache_layout(terminal_size, config.clone());

        config
    }

    /// Calculates layout without caching (internal method)
    fn calculate_layout_uncached(&mut self, terminal_size: (u16, u16)) -> LayoutConfig {
        let (width, height) = terminal_size;

        // Check if terminal size is sufficient for normal operation
        if width < dynamic_ui::MIN_TERMINAL_WIDTH || height < dynamic_ui::MIN_TERMINAL_HEIGHT {
            return self.calculate_emergency_layout(terminal_size);
        }

        let detail_level = self.determine_detail_level(width);
        let horizontal_padding = self.calculate_horizontal_padding(width);
        let content_width = width.saturating_sub(horizontal_padding * 2);
        let content_height = height.saturating_sub(4); // Reserve space for header/footer

        // Ensure minimum content dimensions
        let content_width = std::cmp::max(content_width, dynamic_ui::MIN_CONTENT_WIDTH);
        let content_height = std::cmp::max(content_height, dynamic_ui::MIN_CONTENT_HEIGHT);

        let games_per_page = self.get_optimal_games_per_page(content_height, detail_level);

        // Check if we need to warn about degraded layout
        let degradation_warning = self.check_for_degradation_warning(width, height);

        LayoutConfig {
            content_width,
            content_height,
            games_per_page,
            detail_level,
            horizontal_padding,
            is_emergency_mode: false,
            degradation_warning,
        }
    }

    /// Calculates emergency layout for very small terminal sizes
    fn calculate_emergency_layout(&mut self, terminal_size: (u16, u16)) -> LayoutConfig {
        let (width, height) = terminal_size;

        warn!(
            "Terminal size {}x{} is below minimum {}x{}, using emergency layout",
            width,
            height,
            dynamic_ui::MIN_TERMINAL_WIDTH,
            dynamic_ui::MIN_TERMINAL_HEIGHT
        );

        // Use absolute minimum dimensions if terminal is too small
        let emergency_width = std::cmp::max(width, dynamic_ui::EMERGENCY_MIN_WIDTH);
        let emergency_height = std::cmp::max(height, dynamic_ui::EMERGENCY_MIN_HEIGHT);

        // Force minimal detail level and no padding in emergency mode
        let detail_level = DetailLevel::Minimal;
        let horizontal_padding = 0;
        let content_width = emergency_width.saturating_sub(2); // Minimal margin
        let content_height = emergency_height.saturating_sub(3); // Minimal header/footer space

        // Ensure at least 1 game per page
        let games_per_page =
            std::cmp::max(1, content_height / dynamic_ui::BASE_GAME_HEIGHT) as usize;

        let warning = format!(
            "Terminal size {}x{} is below minimum {}x{}. Using emergency layout.",
            width,
            height,
            dynamic_ui::MIN_TERMINAL_WIDTH,
            dynamic_ui::MIN_TERMINAL_HEIGHT
        );

        debug!(
            "Emergency layout calculated: content_width={}, content_height={}, games_per_page={}",
            content_width, content_height, games_per_page
        );

        LayoutConfig {
            content_width,
            content_height,
            games_per_page,
            detail_level,
            horizontal_padding,
            is_emergency_mode: true,
            degradation_warning: Some(warning),
        }
    }

    /// Checks if the current layout requires degradation warnings
    fn check_for_degradation_warning(&self, width: u16, height: u16) -> Option<String> {
        let mut warnings = Vec::new();

        // Check if width is close to minimum thresholds
        if width < dynamic_ui::MIN_TERMINAL_WIDTH + 10 {
            let warning =
                "Terminal width is close to minimum. Some content may be truncated.".to_string();
            warnings.push(warning.clone());
            debug!("Layout degradation warning: {}", warning);
        }

        // Check if height is close to minimum
        if height < dynamic_ui::MIN_TERMINAL_HEIGHT + 5 {
            let warning =
                "Terminal height is limited. Pagination may be more frequent.".to_string();
            warnings.push(warning.clone());
            debug!("Layout degradation warning: {}", warning);
        }

        // Check if we're forced to use minimal detail level due to width constraints
        if width < dynamic_ui::STANDARD_DETAIL_WIDTH_THRESHOLD
            && width >= dynamic_ui::MIN_TERMINAL_WIDTH
        {
            let warning = "Using minimal detail level due to width constraints.".to_string();
            warnings.push(warning.clone());
            debug!("Layout degradation warning: {}", warning);
        }

        if warnings.is_empty() {
            None
        } else {
            let combined_warning = warnings.join(" ");
            debug!("Combined layout degradation warning: {}", combined_warning);
            Some(combined_warning)
        }
    }

    /// Determines the appropriate detail level based on available width
    pub fn determine_detail_level(&self, available_width: u16) -> DetailLevel {
        if available_width >= dynamic_ui::EXTENDED_DETAIL_WIDTH_THRESHOLD {
            DetailLevel::Extended
        } else if available_width >= dynamic_ui::STANDARD_DETAIL_WIDTH_THRESHOLD {
            DetailLevel::Standard
        } else {
            DetailLevel::Minimal
        }
    }

    /// Calculates optimal number of games per page based on available height
    pub fn get_optimal_games_per_page(
        &self,
        available_height: u16,
        detail_level: DetailLevel,
    ) -> usize {
        let height_per_game = match detail_level {
            DetailLevel::Minimal => dynamic_ui::BASE_GAME_HEIGHT,
            DetailLevel::Standard => dynamic_ui::BASE_GAME_HEIGHT + 1,
            DetailLevel::Extended => {
                dynamic_ui::BASE_GAME_HEIGHT + dynamic_ui::EXTENDED_GAME_HEIGHT_BONUS
            }
        };

        let max_games = available_height / height_per_game;
        std::cmp::max(1, max_games as usize) // Ensure at least 1 game per page
    }

    /// Calculates horizontal padding based on terminal width
    fn calculate_horizontal_padding(&self, width: u16) -> u16 {
        let max_padding = (width as f32 * dynamic_ui::MAX_HORIZONTAL_PADDING_PERCENT) as u16;
        std::cmp::min(max_padding, 10) // Cap at 10 characters padding
    }

    /// Gets current terminal dimensions
    pub fn current_dimensions(&self) -> (u16, u16) {
        self.current_dimensions
    }

    /// Caches a layout configuration
    fn cache_layout(&mut self, terminal_size: (u16, u16), config: LayoutConfig) {
        let cached_data = CachedLayoutData::new(config, terminal_size);
        self.layout_cache.insert(terminal_size, cached_data);

        // Limit cache size to prevent memory growth
        if self.layout_cache.len() > dynamic_ui::MAX_LAYOUT_CACHE_ENTRIES {
            self.cleanup_old_cache_entries();
        }
    }

    /// Finds a candidate for incremental update
    fn find_incremental_update_candidate(
        &self,
        terminal_size: (u16, u16),
    ) -> Option<&CachedLayoutData> {
        self.layout_cache
            .values()
            .find(|cached| !cached.is_expired() && cached.is_incremental_update(terminal_size))
    }

    /// Attempts to perform an incremental update from cached data
    fn try_incremental_update(
        &self,
        cached: &CachedLayoutData,
        new_size: (u16, u16),
    ) -> Option<LayoutConfig> {
        let (new_width, new_height) = new_size;
        let (old_width, _old_height) = cached.terminal_size;

        // Only do incremental updates for small changes that don't affect detail level
        let old_detail = self.determine_detail_level(old_width);
        let new_detail = self.determine_detail_level(new_width);

        if old_detail != new_detail {
            return None; // Detail level change requires full recalculation
        }

        // Calculate incremental changes
        let mut updated_config = cached.config.clone();

        // Update dimensions
        let horizontal_padding = self.calculate_horizontal_padding(new_width);
        updated_config.content_width = new_width.saturating_sub(horizontal_padding * 2);
        updated_config.content_width =
            std::cmp::max(updated_config.content_width, dynamic_ui::MIN_CONTENT_WIDTH);

        updated_config.content_height = new_height.saturating_sub(4);
        updated_config.content_height = std::cmp::max(
            updated_config.content_height,
            dynamic_ui::MIN_CONTENT_HEIGHT,
        );

        updated_config.horizontal_padding = horizontal_padding;
        updated_config.games_per_page =
            self.get_optimal_games_per_page(updated_config.content_height, new_detail);

        // Update degradation warning
        updated_config.degradation_warning =
            self.check_for_degradation_warning(new_width, new_height);

        Some(updated_config)
    }

    /// Cleans up cache if needed
    fn cleanup_cache_if_needed(&mut self) {
        if self.last_cache_cleanup.elapsed()
            > Duration::from_secs(dynamic_ui::CACHE_CLEANUP_INTERVAL_SECONDS)
        {
            self.cleanup_expired_cache_entries();
            self.last_cache_cleanup = Instant::now();
        }
    }

    /// Removes expired cache entries
    fn cleanup_expired_cache_entries(&mut self) {
        let initial_size = self.layout_cache.len();
        self.layout_cache.retain(|_, cached| !cached.is_expired());
        let removed = initial_size - self.layout_cache.len();

        if removed > 0 {
            trace!("Cleaned up {} expired layout cache entries", removed);
        }
    }

    /// Removes old cache entries when cache is full
    fn cleanup_old_cache_entries(&mut self) {
        // Remove the oldest 25% of entries
        let target_size = (self.layout_cache.len() * 3) / 4;

        let mut entries: Vec<_> = self.layout_cache.iter().collect();
        entries.sort_by_key(|(_, cached)| cached.cached_at);

        let to_remove: Vec<_> = entries
            .iter()
            .take(self.layout_cache.len() - target_size)
            .map(|(k, _)| **k)
            .collect();

        for key in to_remove {
            self.layout_cache.remove(&key);
        }

        trace!(
            "Cleaned up old layout cache entries, new size: {}",
            self.layout_cache.len()
        );
    }

    /// Gets a string buffer from the pool for optimized rendering
    pub fn get_string_buffer(&mut self, estimated_size: usize) -> String {
        self.string_buffer_pool.get_buffer(estimated_size)
    }

    /// Returns a string buffer to the pool
    pub fn return_string_buffer(&mut self, buffer: String) {
        self.string_buffer_pool.return_buffer(buffer);
    }

    /// Gets cache statistics for monitoring
    pub fn get_cache_stats(&self) -> LayoutCacheStats {
        let expired_count = self
            .layout_cache
            .values()
            .filter(|cached| cached.is_expired())
            .count();

        LayoutCacheStats {
            total_entries: self.layout_cache.len(),
            expired_entries: expired_count,
            active_entries: self.layout_cache.len() - expired_count,
            buffer_pool_size: self.string_buffer_pool.buffers.len(),
        }
    }

    /// Clears all cached layout data (for testing or memory management)
    pub fn clear_cache(&mut self) {
        self.layout_cache.clear();
        self.string_buffer_pool.buffers.clear();
        trace!("Layout cache cleared");
    }

    /// Safely calculates layout with comprehensive error handling
    pub fn calculate_layout_safe(
        &mut self,
        terminal_size: (u16, u16),
    ) -> Result<LayoutConfig, AppError> {
        let (width, height) = terminal_size;

        debug!(
            "Attempting safe layout calculation for terminal size: {}x{}",
            width, height
        );

        // Validate terminal dimensions
        if width == 0 || height == 0 {
            warn!(
                "Layout calculation failed: terminal dimensions cannot be zero ({}x{})",
                width, height
            );
            return Err(AppError::layout_calculation_failed(
                "Terminal dimensions cannot be zero",
            ));
        }

        // Check for extremely small terminal that can't display anything useful
        if width < dynamic_ui::EMERGENCY_MIN_WIDTH || height < dynamic_ui::EMERGENCY_MIN_HEIGHT {
            warn!(
                "Terminal size {}x{} is below emergency minimum {}x{}",
                width,
                height,
                dynamic_ui::EMERGENCY_MIN_WIDTH,
                dynamic_ui::EMERGENCY_MIN_HEIGHT
            );
            return Err(AppError::terminal_too_small(
                width,
                height,
                dynamic_ui::EMERGENCY_MIN_WIDTH,
                dynamic_ui::EMERGENCY_MIN_HEIGHT,
            ));
        }

        // Calculate layout with error handling
        let layout = self.calculate_layout(terminal_size);

        // Validate the calculated layout
        if layout.content_width == 0 || layout.content_height == 0 {
            warn!(
                "Layout calculation resulted in zero content dimensions: width={}, height={}",
                layout.content_width, layout.content_height
            );
            return Err(AppError::layout_calculation_failed(
                "Calculated layout has zero content dimensions",
            ));
        }

        if layout.games_per_page == 0 {
            warn!("Layout calculation resulted in zero games per page");
            return Err(AppError::layout_calculation_failed(
                "Calculated layout cannot display any games",
            ));
        }

        debug!(
            "Safe layout calculation successful: content_width={}, content_height={}, games_per_page={}, detail_level={:?}",
            layout.content_width, layout.content_height, layout.games_per_page, layout.detail_level
        );

        Ok(layout)
    }

    /// Validates terminal size and returns appropriate error if invalid
    pub fn validate_terminal_size(&self, terminal_size: (u16, u16)) -> Result<(), AppError> {
        let (width, height) = terminal_size;

        if width == 0 || height == 0 {
            return Err(AppError::layout_calculation_failed(
                "Terminal dimensions cannot be zero",
            ));
        }

        if width < dynamic_ui::EMERGENCY_MIN_WIDTH || height < dynamic_ui::EMERGENCY_MIN_HEIGHT {
            return Err(AppError::terminal_too_small(
                width,
                height,
                dynamic_ui::EMERGENCY_MIN_WIDTH,
                dynamic_ui::EMERGENCY_MIN_HEIGHT,
            ));
        }

        Ok(())
    }

    /// Calculates content positioning for UI elements
    pub fn calculate_content_positioning(
        &self,
        layout_config: &LayoutConfig,
    ) -> ContentPositioning {
        let (_, height) = self.current_dimensions;

        ContentPositioning {
            header_y: 0,
            content_start_y: 2, // Leave space for header and subheader
            content_end_y: height.saturating_sub(2), // Leave space for footer
            footer_y: height.saturating_sub(1),
            left_margin: layout_config.horizontal_padding,
            right_margin: layout_config.horizontal_padding,
        }
    }
}

impl Default for LayoutCalculator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_layout_calculator_creation() {
        let calculator = LayoutCalculator::new();
        assert_eq!(calculator.min_width, dynamic_ui::MIN_TERMINAL_WIDTH);
        assert_eq!(calculator.min_height, dynamic_ui::MIN_TERMINAL_HEIGHT);
    }

    #[test]
    fn test_detail_level_determination() {
        let calculator = LayoutCalculator::new();

        // Test minimal detail level
        assert_eq!(calculator.determine_detail_level(79), DetailLevel::Minimal);
        assert_eq!(calculator.determine_detail_level(80), DetailLevel::Minimal);

        // Test standard detail level
        assert_eq!(
            calculator.determine_detail_level(100),
            DetailLevel::Standard
        );
        assert_eq!(
            calculator.determine_detail_level(119),
            DetailLevel::Standard
        );

        // Test extended detail level
        assert_eq!(
            calculator.determine_detail_level(120),
            DetailLevel::Extended
        );
        assert_eq!(
            calculator.determine_detail_level(200),
            DetailLevel::Extended
        );
    }

    #[test]
    fn test_games_per_page_calculation() {
        let calculator = LayoutCalculator::new();

        // Test minimal detail level
        let games_minimal = calculator.get_optimal_games_per_page(24, DetailLevel::Minimal);
        assert_eq!(games_minimal, 8); // 24 / 3 = 8

        // Test standard detail level
        let games_standard = calculator.get_optimal_games_per_page(24, DetailLevel::Standard);
        assert_eq!(games_standard, 6); // 24 / 4 = 6

        // Test extended detail level
        let games_extended = calculator.get_optimal_games_per_page(24, DetailLevel::Extended);
        assert_eq!(games_extended, 4); // 24 / 5 = 4 (3 + 2 bonus)

        // Test minimum games per page
        let games_small = calculator.get_optimal_games_per_page(2, DetailLevel::Extended);
        assert_eq!(games_small, 1); // Should be at least 1
    }

    #[test]
    fn test_layout_calculation() {
        let mut calculator = LayoutCalculator::new();

        // Test with minimal terminal size
        let layout = calculator.calculate_layout((80, 24));
        assert_eq!(layout.detail_level, DetailLevel::Minimal);
        assert!(layout.content_width <= 80);
        assert!(layout.content_height <= 20); // 24 - 4 for header/footer
        assert!(layout.games_per_page > 0);
        assert!(!layout.is_emergency_mode);

        // Test with large terminal size
        let layout_large = calculator.calculate_layout((150, 40));
        assert_eq!(layout_large.detail_level, DetailLevel::Extended);
        assert!(layout_large.content_width <= 150);
        assert!(layout_large.content_height <= 36); // 40 - 4 for header/footer
        assert!(layout_large.games_per_page > 0);
        assert!(!layout_large.is_emergency_mode);
    }

    #[test]
    fn test_layout_caching() {
        let mut calculator = LayoutCalculator::new();

        // First calculation should cache the result
        let layout1 = calculator.calculate_layout((100, 30));
        let stats1 = calculator.get_cache_stats();
        assert_eq!(stats1.total_entries, 1);

        // Second calculation with same size should use cache
        let layout2 = calculator.calculate_layout((100, 30));
        assert_eq!(layout1.content_width, layout2.content_width);
        assert_eq!(layout1.games_per_page, layout2.games_per_page);

        // Different size should create new cache entry
        let _layout3 = calculator.calculate_layout((120, 35));
        let stats2 = calculator.get_cache_stats();
        assert_eq!(stats2.total_entries, 2);
    }

    #[test]
    fn test_incremental_layout_updates() {
        let mut calculator = LayoutCalculator::new();

        // Create initial layout
        let layout1 = calculator.calculate_layout((100, 30));

        // Small change should trigger incremental update
        let layout2 = calculator.calculate_layout((103, 32));
        assert_eq!(layout1.detail_level, layout2.detail_level); // Should be same detail level
        assert!(layout2.content_width > layout1.content_width); // But different dimensions
    }

    #[test]
    fn test_cache_cleanup() {
        let mut calculator = LayoutCalculator::new();

        // Fill cache with many entries
        for i in 80..130 {
            calculator.calculate_layout((i, 24));
        }

        let stats_before = calculator.get_cache_stats();
        assert!(stats_before.total_entries > 40);

        // Force cleanup
        calculator.cleanup_old_cache_entries();

        let stats_after = calculator.get_cache_stats();
        assert!(stats_after.total_entries < stats_before.total_entries);
    }

    #[test]
    fn test_string_buffer_pool() {
        let mut calculator = LayoutCalculator::new();

        // Get buffer from pool
        let buffer1 = calculator.get_string_buffer(1024);
        assert_eq!(buffer1.len(), 0);
        assert!(buffer1.capacity() >= 1024);

        // Return buffer to pool
        calculator.return_string_buffer(buffer1);

        let stats = calculator.get_cache_stats();
        assert_eq!(stats.buffer_pool_size, 1);

        // Get buffer again (should reuse)
        let _buffer2 = calculator.get_string_buffer(512);
        let stats2 = calculator.get_cache_stats();
        assert_eq!(stats2.buffer_pool_size, 0); // Buffer was taken from pool
    }

    #[test]
    fn test_horizontal_padding_calculation() {
        let calculator = LayoutCalculator::new();

        // Test padding calculation
        let padding_small = calculator.calculate_horizontal_padding(80);
        assert!(padding_small <= 8); // 10% of 80 = 8

        let padding_large = calculator.calculate_horizontal_padding(200);
        assert_eq!(padding_large, 10); // Capped at 10
    }

    #[test]
    fn test_content_positioning_calculation() {
        let mut calculator = LayoutCalculator::new();
        let layout = calculator.calculate_layout((100, 30));
        let positioning = calculator.calculate_content_positioning(&layout);

        // Test positioning values
        assert_eq!(positioning.header_y, 0);
        assert_eq!(positioning.content_start_y, 2);
        assert_eq!(positioning.content_end_y, 28); // 30 - 2
        assert_eq!(positioning.footer_y, 29); // 30 - 1
        assert_eq!(positioning.left_margin, layout.horizontal_padding);
        assert_eq!(positioning.right_margin, layout.horizontal_padding);
    }

    #[test]
    fn test_content_positioning_with_small_terminal() {
        let mut calculator = LayoutCalculator::new();
        let layout = calculator.calculate_layout((80, 24));
        let positioning = calculator.calculate_content_positioning(&layout);

        // Test positioning values for minimum size
        assert_eq!(positioning.header_y, 0);
        assert_eq!(positioning.content_start_y, 2);
        assert_eq!(positioning.content_end_y, 22); // 24 - 2
        assert_eq!(positioning.footer_y, 23); // 24 - 1
        assert!(positioning.left_margin > 0);
        assert!(positioning.right_margin > 0);
    }

    #[test]
    fn test_various_terminal_size_scenarios() {
        let mut calculator = LayoutCalculator::new();

        // Test very small terminal (edge case)
        let layout_tiny = calculator.calculate_layout((60, 15));
        assert_eq!(layout_tiny.detail_level, DetailLevel::Minimal);
        assert!(layout_tiny.games_per_page >= 1);
        assert!(layout_tiny.content_width > 0);

        // Test medium terminal
        let layout_medium = calculator.calculate_layout((110, 35));
        assert_eq!(layout_medium.detail_level, DetailLevel::Standard);
        assert!(layout_medium.games_per_page > layout_tiny.games_per_page);

        // Test very large terminal
        let layout_large = calculator.calculate_layout((200, 60));
        assert_eq!(layout_large.detail_level, DetailLevel::Extended);
        assert!(layout_large.games_per_page > layout_medium.games_per_page);

        // Test ultra-wide terminal
        let layout_wide = calculator.calculate_layout((300, 30));
        assert_eq!(layout_wide.detail_level, DetailLevel::Extended);
        assert_eq!(layout_wide.horizontal_padding, 10); // Should be capped
    }

    #[test]
    fn test_detail_level_boundary_conditions() {
        let calculator = LayoutCalculator::new();

        // Test exact boundary values
        assert_eq!(calculator.determine_detail_level(99), DetailLevel::Minimal);
        assert_eq!(
            calculator.determine_detail_level(100),
            DetailLevel::Standard
        );
        assert_eq!(
            calculator.determine_detail_level(119),
            DetailLevel::Standard
        );
        assert_eq!(
            calculator.determine_detail_level(120),
            DetailLevel::Extended
        );

        // Test extreme values
        assert_eq!(calculator.determine_detail_level(1), DetailLevel::Minimal);
        assert_eq!(
            calculator.determine_detail_level(u16::MAX),
            DetailLevel::Extended
        );
    }

    #[test]
    fn test_games_per_page_edge_cases() {
        let calculator = LayoutCalculator::new();

        // Test with very small height
        assert_eq!(
            calculator.get_optimal_games_per_page(1, DetailLevel::Minimal),
            1
        );
        assert_eq!(
            calculator.get_optimal_games_per_page(2, DetailLevel::Standard),
            1
        );
        assert_eq!(
            calculator.get_optimal_games_per_page(4, DetailLevel::Extended),
            1
        );

        // Test with zero height (edge case)
        assert_eq!(
            calculator.get_optimal_games_per_page(0, DetailLevel::Minimal),
            1
        );

        // Test with large height
        let large_height_games = calculator.get_optimal_games_per_page(100, DetailLevel::Minimal);
        assert_eq!(large_height_games, 33); // 100 / 3 = 33

        let large_height_extended =
            calculator.get_optimal_games_per_page(100, DetailLevel::Extended);
        assert_eq!(large_height_extended, 20); // 100 / 5 = 20
    }

    #[test]
    fn test_layout_consistency_across_size_changes() {
        let mut calculator = LayoutCalculator::new();

        // Test that layout calculations are consistent (should use cache)
        let layout1 = calculator.calculate_layout((100, 30));
        let layout2 = calculator.calculate_layout((100, 30));

        assert_eq!(layout1.detail_level, layout2.detail_level);
        assert_eq!(layout1.games_per_page, layout2.games_per_page);
        assert_eq!(layout1.content_width, layout2.content_width);
        assert_eq!(layout1.content_height, layout2.content_height);

        // Test that dimensions are properly updated
        calculator.calculate_layout((150, 40));
        assert_eq!(calculator.current_dimensions(), (150, 40));
    }

    #[test]
    fn test_content_width_calculation() {
        let mut calculator = LayoutCalculator::new();

        // Test that content width accounts for padding
        let layout = calculator.calculate_layout((100, 30));
        let expected_content_width = 100 - (layout.horizontal_padding * 2);
        assert_eq!(layout.content_width, expected_content_width);

        // Test with minimum width
        let layout_min = calculator.calculate_layout((80, 24));
        assert!(layout_min.content_width > 0);
        assert!(layout_min.content_width <= 80);
    }

    #[test]
    fn test_content_height_calculation() {
        let mut calculator = LayoutCalculator::new();

        // Test that content height accounts for header/footer
        let layout = calculator.calculate_layout((100, 30));
        assert_eq!(layout.content_height, 26); // 30 - 4 for header/footer

        // Test with minimum height
        let layout_min = calculator.calculate_layout((80, 24));
        assert_eq!(layout_min.content_height, 20); // 24 - 4

        // Test with very small height (triggers emergency layout)
        let layout_tiny = calculator.calculate_layout((80, 5));
        assert!(layout_tiny.is_emergency_mode);
        // Emergency layout uses max(5, 10) - 3 = 7 for content height
        assert_eq!(layout_tiny.content_height, 7);
    }

    #[test]
    fn test_emergency_layout_mode() {
        let mut calculator = LayoutCalculator::new();

        // Test with terminal size below minimum
        let layout = calculator.calculate_layout((60, 15));
        assert!(layout.is_emergency_mode);
        assert!(layout.degradation_warning.is_some());
        assert_eq!(layout.detail_level, DetailLevel::Minimal);
        assert_eq!(layout.horizontal_padding, 0); // No padding in emergency mode
        assert!(layout.games_per_page >= 1);

        // Test with extremely small terminal
        let layout_tiny = calculator.calculate_layout((30, 8));
        assert!(layout_tiny.is_emergency_mode);
        assert!(layout_tiny.degradation_warning.is_some());
        assert!(layout_tiny.content_width > 0);
        assert!(layout_tiny.content_height > 0);
    }

    #[test]
    fn test_safe_layout_calculation() {
        let mut calculator = LayoutCalculator::new();

        // Test successful safe calculation
        let result = calculator.calculate_layout_safe((100, 30));
        assert!(result.is_ok());
        let layout = result.unwrap();
        assert!(!layout.is_emergency_mode);

        // Test with zero dimensions
        let result = calculator.calculate_layout_safe((0, 30));
        assert!(result.is_err());

        let result = calculator.calculate_layout_safe((100, 0));
        assert!(result.is_err());

        // Test with extremely small dimensions
        let result = calculator.calculate_layout_safe((20, 5));
        assert!(result.is_err());
    }

    #[test]
    fn test_terminal_size_validation() {
        let calculator = LayoutCalculator::new();

        // Test valid sizes
        assert!(calculator.validate_terminal_size((80, 24)).is_ok());
        assert!(calculator.validate_terminal_size((120, 40)).is_ok());

        // Test invalid sizes
        assert!(calculator.validate_terminal_size((0, 24)).is_err());
        assert!(calculator.validate_terminal_size((80, 0)).is_err());
        assert!(calculator.validate_terminal_size((20, 5)).is_err());
    }

    #[test]
    fn test_degradation_warnings() {
        let mut calculator = LayoutCalculator::new();

        // Test layout with warnings
        let layout = calculator.calculate_layout((85, 26)); // Just above minimum
        assert!(layout.degradation_warning.is_some());
        assert!(!layout.is_emergency_mode);

        // Test layout without warnings
        let layout_good = calculator.calculate_layout((120, 40));
        assert!(layout_good.degradation_warning.is_none());
        assert!(!layout_good.is_emergency_mode);

        // Test emergency mode has warnings
        let layout_emergency = calculator.calculate_layout((60, 15));
        assert!(layout_emergency.degradation_warning.is_some());
        assert!(layout_emergency.is_emergency_mode);
    }

    #[test]
    fn test_layout_error_recovery() {
        let mut calculator = LayoutCalculator::new();

        // Test recovery from layout calculation errors
        let error = AppError::layout_calculation_failed("Test error");
        assert!(error.to_string().contains("Test error"));

        // Test terminal too small error
        let error = AppError::terminal_too_small(30, 10, 40, 15);
        assert!(error.to_string().contains("30x10"));
        assert!(error.to_string().contains("40x15"));

        // Test that emergency layout can handle very small sizes
        let layout = calculator.calculate_layout((35, 12));
        assert!(layout.is_emergency_mode);
        assert!(layout.content_width > 0);
        assert!(layout.content_height > 0);
        assert!(layout.games_per_page > 0);
    }

    #[test]
    fn test_layout_validation_edge_cases() {
        let calculator = LayoutCalculator::new();

        // Test validation with edge cases
        assert!(calculator.validate_terminal_size((40, 10)).is_ok()); // Exactly at emergency minimum
        assert!(calculator.validate_terminal_size((39, 10)).is_err()); // Below emergency minimum
        assert!(calculator.validate_terminal_size((40, 9)).is_err()); // Below emergency minimum

        // Test with maximum values
        assert!(
            calculator
                .validate_terminal_size((u16::MAX, u16::MAX))
                .is_ok()
        );
    }

    #[test]
    fn test_positioning_edge_cases() {
        let mut calculator = LayoutCalculator::new();

        // Test with minimum terminal size
        let layout_min = calculator.calculate_layout((80, 24));
        let pos_min = calculator.calculate_content_positioning(&layout_min);

        assert!(pos_min.content_start_y < pos_min.content_end_y);
        assert!(pos_min.content_end_y < pos_min.footer_y);
        assert_eq!(pos_min.header_y, 0);

        // Test with very small terminal
        let layout_tiny = calculator.calculate_layout((60, 10));
        let pos_tiny = calculator.calculate_content_positioning(&layout_tiny);

        assert!(pos_tiny.content_start_y <= pos_tiny.content_end_y);
        assert_eq!(pos_tiny.footer_y, 9); // 10 - 1
    }
}
